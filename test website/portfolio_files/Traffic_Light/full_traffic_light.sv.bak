module full_traffic_light(
//traffic_light_controller
input clk_27,
input reset,
input de_bug,
input left_turn_request,

output northbound_green, northbound_amber, northbound_red,
output southbound_green, southbound_amber, southbound_red,
output [1:0] southbound_arrow,
output eastbound_green, eastbound_amber, eastbound_red,
output westbound_green, westbound_amber, westbound_red
);

wire clk;

wire entering_state_1, entering_state_2, entering_state_3, entering_state_4a, entering_state_4, entering_state_5, entering_state_6;

wire state_1, state_2, state_3, state_4a, state_4, state_5, state_6;

wire state_1_d, state_2_d, state_3_d, state_4a_d, state_4_d, state_5_d, state_6_d;

wire staying_in_state_1, staying_in_state_2, staying_in_state_3, staying_in_state_4a, staying_in_state_4, staying_in_state_5, staying_in_state_6;

wire [5:0] timer;

wire reset_bar;

assign reset_bar = ~reset;



wire clk1;
reg [24:0] counter;

// making 1hz clock
always @ (posedge clk_27)
if (counter < 25'd13500000)
	counter = counter + 1;
else
	begin
	counter = 25'd0;
	clk1 = ~clk1;
	end
	


wire clk_10;
reg [24:0] counter_10;

always @ (posedge clk_27)
if (counter_10 < 25'd1350000)
	counter_10 = counter_10 + 1;
else
	begin
	counter_10 = 25'd0;
	clk_10 = ~clk_10;
	end

always @ *	
if (de_bug == 1'b1)
	clk = clk_10;
else
	clk = clk1;
	

// timer stuff

always @ (posedge clk or negedge reset)
if (reset == 1'b0)
	timer <= 6'd60; // state 1
	
else if (entering_state_1 == 1'b1)
	timer <= 6'd60; // state 1
	
else if (entering_state_2 == 1'b1)
	timer <= 6'd6; // state 2
	
else if (entering_state_3 == 1'b1)
	timer <= 6'd2; // state 3
	
else if (entering_state_4a == 1'b1)
	timer <= 6'd20; // state 4a	
	
else if (entering_state_4 == 1'b1)
	timer <= 6'd60; // state 4
	
else if (entering_state_5 == 1'b1)
	timer <= 6'd6; // state 5	

else if (entering_state_6 == 1'b1)
	timer <= 6'd2; // state 6	
	
else if (timer == 6'd1)
		timer <= timer;
		
else 
		timer <= timer - 6'd1;
	

// STATE 1	
	
// make the state 1 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_1 <= 1'b1;
	else state_1 <= state_1_d;

//logic for entering state 1
always @ *
	if( (state_6 == 1'b1) && (timer == 6'd1) )
		entering_state_1 <= 1'b1;
	else entering_state_1 <= 1'b0;
//logic for staying in state 1
always @ *
	if( (state_1 == 1'b1) && (timer != 6'd1) )
		staying_in_state_1 <= 1'b1;
	else staying_in_state_1 <= 1'b0;
// make the d-input for state_1 flip/flop
always @ *
	if( entering_state_1 == 1'b1 )
		// enter state 1 on next posedge clk
		state_1_d <= 1'b1;
	else if ( staying_in_state_1 == 1'b1)
		// stay in state 1 on next posedge clk
		state_1_d <= 1'b1;
	else // not in state 1 on next posedge clk
		state_1_d <= 1'b0;


	
	
	
// STATE 2	
	
// make the state 2 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_2 <= 1'b0;
	else state_2 <= state_2_d;

//logic for entering state 2
always @ *
	if( (state_1 == 1'b1) && (timer == 6'd1) )
		entering_state_2 <= 1'b1;
	else entering_state_2 <= 1'b0;
//logic for staying in state 2
always @ *
	if( (state_2 == 1'b1) && (timer != 6'd1) )
		staying_in_state_2 <= 1'b1;
	else staying_in_state_2 <= 1'b0;
// make the d-input for state_2 flip/flop
always @ *
	if( entering_state_2 == 1'b1 )
		// enter state 2 on next posedge clk
		state_2_d <= 1'b1;
	else if ( staying_in_state_2 == 1'b1)
		// stay in state 2 on next posedge clk
		state_2_d <= 1'b1;
	else // not in state 2 on next posedge clk
		state_2_d <= 1'b0;

		
		
		
		
// STATE 3	
	
// make the state 3 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_3 <= 1'b0;
	else state_3 <= state_3_d;

//logic for entering state 3
always @ *
	if( (state_2 == 1'b1) && (timer == 6'd1) )
		entering_state_3 <= 1'b1;
	else entering_state_3 <= 1'b0;
//logic for staying in state 3
always @ *
	if( (state_3 == 1'b1) && (timer != 6'd1) )
		staying_in_state_3 <= 1'b1;
	else staying_in_state_3 <= 1'b0;
// make the d-input for state_3 flip/flop
always @ *
	if( entering_state_3 == 1'b1 )
		// enter state 3 on next posedge clk
		state_3_d <= 1'b1;
	else if ( staying_in_state_3 == 1'b1)
		// stay in state 2 on next posedge clk
		state_3_d <= 1'b1;
	else // not in state 2 on next posedge clk
		state_3_d <= 1'b0;		

		
// STATE 4a	
	
// make the state 4a flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_4a <= 1'b0;
	else state_4a <= state_4a_d;

//logic for entering state 4a
always @ *
	if( (state_3 == 1'b1) && (left_turn_request == 1'b0) && (timer == 6'd1) )
		entering_state_4a <= 1'b1;
	else entering_state_4a <= 1'b0;
//logic for staying in state 4a
always @ *
	if( (state_4a == 1'b1) && (timer != 6'd1) )
		staying_in_state_4a <= 1'b1;
	else staying_in_state_4a <= 1'b0;
// make the d-input for state_4a flip/flop
always @ *
	if( entering_state_4a == 1'b1 )
		// enter state 4a on next posedge clk
		state_4a_d <= 1'b1;
	else if ( staying_in_state_4a == 1'b1)
		// stay in state 2 on next posedge clk
		state_4a_d <= 1'b1;
	else // not in state 2 on next posedge clk
		state_4a_d <= 1'b0;	


		
		
		
		
		
		
// STATE 4	
	
// make the state 4 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_4 <= 1'b0;
	else state_4 <= state_4_d;

//logic for entering state 4
always @ *
	if( ((state_4a == 1'b1)|((state_3 == 1'b1)&(left_turn_request == 1'b1)) && (timer == 6'd1)))
		entering_state_4 <= 1'b1;
	else entering_state_4 <= 1'b0;
//logic for staying in state 4
always @ *
	if( (state_4 == 1'b1) && (timer != 6'd1) )
		staying_in_state_4 <= 1'b1;
	else staying_in_state_4 <= 1'b0;
// make the d-input for state_4 flip/flop
always @ *
	if( entering_state_4 == 1'b1 )
		// enter state 4 on next posedge clk
		state_4_d <= 1'b1;
	else if ( staying_in_state_4 == 1'b1)
		// stay in state 4 on next posedge clk
		state_4_d <= 1'b1;
	else // not in state 4 on next posedge clk
		state_4_d <= 1'b0;




// STATE 5	
	
// make the state 5 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_5 <= 1'b0;
	else state_5 <= state_5_d;

//logic for entering state 5
always @ *
	if( (state_4 == 1'b1) && (timer == 6'd1) )
		entering_state_5 <= 1'b1;
	else entering_state_5 <= 1'b0;
//logic for staying in state 5
always @ *
	if( (state_5 == 1'b1) && (timer != 6'd1) )
		staying_in_state_5 <= 1'b1;
	else staying_in_state_5 <= 1'b0;
// make the d-input for state_5 flip/flop
always @ *
	if( entering_state_5 == 1'b1 )
		// enter state 5 on next posedge clk
		state_5_d <= 1'b1;
	else if ( staying_in_state_5 == 1'b1)
		// stay in state 5 on next posedge clk
		state_5_d <= 1'b1;
	else // not in state 2 on next posedge clk
		state_5_d <= 1'b0;	
	




// STATE 6	
	
// make the state 6 flip flop	
always @ (posedge clk or posedge reset_bar)
	if (reset_bar == 1'b1) // keys are active low
		state_6 <= 1'b0;
	else state_6 <= state_6_d;

//logic for entering state 6
always @ *
	if( (state_5 == 1'b1) && (timer == 6'd1) )
		entering_state_6 <= 1'b1;
	else entering_state_6 <= 1'b0;
//logic for staying in state 6
always @ *
	if( (state_6 == 1'b1) && (timer != 6'd1) )
		staying_in_state_6 <= 1'b1;
	else staying_in_state_6 <= 1'b0;
// make the d-input for state_6 flip/flop
always @ *
	if( entering_state_6 == 1'b1 )
		// enter state 6 on next posedge clk
		state_6_d <= 1'b1;
	else if ( staying_in_state_6 == 1'b1)
		// stay in state 6 on next posedge clk
		state_6_d <= 1'b1;
	else // not in state 6 on next posedge clk
		state_6_d <= 1'b0;	
	

// EAST BOUND	

// RED	
always @ *
if ((state_3 | state_4 | state_5 | state_6 | state_4a) == 1'b1) 
		eastbound_red = 1'b0;
else
		eastbound_red = 1'b1;
		
// AMBER
always @ *
if (state_2 == 1'b1)
	eastbound_amber = 1'b0;
else
	eastbound_amber = 1'b1;

// GREEN
always @ *
if (state_1 == 1'b1)
	eastbound_green = 1'b0;
else
	eastbound_green = 1'b1;
		
		
		
// North Bound	

// RED	
always @ *
if ((state_1 | state_2 | state_3 | state_6 | state_4a) == 1'b1) 
		northbound_red = 1'b0;
else
		northbound_red = 1'b1;
		
// AMBER
always @ *
if (state_5 == 1'b1)
	northbound_amber = 1'b0;
else
	northbound_amber = 1'b1;

// GREEN
always @ *
if (state_4 == 1'b1)
	northbound_green = 1'b0;
else
	northbound_green = 1'b1;		
		




// South Bound	

// RED	
always @ *
if ((state_1 | state_2 | state_3 | state_6) == 1'b1) 
		southbound_red = 1'b0; // on because negative logic
else
		southbound_red = 1'b1; // off
		
// AMBER
always @ *
if ((state_5 == 1'b1) | (state_4a == 1'b1))
	southbound_amber = 1'b0;
else
	southbound_amber = 1'b1;

// GREEN
always @ *
if (state_4 == 1'b1)
	southbound_green = 1'b0;
else
	southbound_green = 1'b1;
	
//Arrow
always @ *
if (state_4a == 1'b1)
	southbound_arrow = 2'b00;
	
else
	southbound_arrow = 2'b11;


	
	
	
	

// West Bound	

// RED	
always @ *
if ((state_3 | state_4 | state_5 | state_6 | state_4a) == 1'b1) 
		westbound_red = 1'b0;
else
		westbound_red = 1'b1;
		
// AMBER
always @ *
if (state_2 == 1'b1)
	westbound_amber = 1'b0;
else
	westbound_amber = 1'b1;

// GREEN
always @ *
if (state_1 == 1'b1)
	westbound_green = 1'b0;
else
	westbound_green = 1'b1;		
		
		
endmodule